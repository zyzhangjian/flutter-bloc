{"version":3,"file":"extension.js","mappings":"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","sources":["webpack://flutterBlocTemplate/./src/extension.ts","webpack://flutterBlocTemplate/external commonjs \"vscode\"","webpack://flutterBlocTemplate/external node-commonjs \"fs\"","webpack://flutterBlocTemplate/external node-commonjs \"path\"","webpack://flutterBlocTemplate/webpack/bootstrap","webpack://flutterBlocTemplate/webpack/startup"],"sourcesContent":["import * as vscode from \"vscode\";\nimport * as path from \"path\";\nimport * as fs from \"fs\";\n\n/**\n * Activates the extension and registers the command for generating Flutter Bloc/Cubit templates.\n * This is the main entry point of the extension.\n */\nexport function activate(context: vscode.ExtensionContext) {\n    // Register the command that will be invoked when users select \"Flutter Bloc: New Bloc Template\"\n  // from the context menu or command palette\n  const disposable = vscode.commands.registerCommand(\n    \"flutter bloc.newBlocTemplate\",\n    async (uri: vscode.Uri) => {\n      if (!uri || !uri.fsPath) {\n        const folderUri = await vscode.window.showOpenDialog({\n          canSelectFolders: true,\n          canSelectFiles: false,\n          openLabel: \"Select Folder\",\n        });\n\n        if (!folderUri || folderUri.length === 0) {\n          vscode.window.showErrorMessage(\"No folder selected.\");\n          return;\n        }\n\n        uri = folderUri[0];\n      }\n\n      // Check if URI is provided\n      if (!uri) {\n        const workspaceFolders = vscode.workspace.workspaceFolders;\n\n        if (!workspaceFolders || workspaceFolders.length === 0) {\n          vscode.window.showErrorMessage(\n            \"No folder selected and no workspace is open. Please open a workspace or select a folder.\"\n          );\n          return;\n        }\n\n        // Use the first workspace folder as the default path\n        uri = workspaceFolders[0].uri;\n      }\n\n      // Validate the URI\n      if (uri.scheme !== \"file\") {\n        vscode.window.showErrorMessage(\n          \"Selected resource is not a valid folder. Please try again.\"\n        );\n        console.error(\"Invalid URI scheme:\", uri.scheme);\n        return;\n      }\n\n      // Ensure the selected resource is a folder\n      const selectedPath = uri.fsPath;\n      if (\n        !fs.existsSync(selectedPath) ||\n        !fs.lstatSync(selectedPath).isDirectory()\n      ) {\n        vscode.window.showErrorMessage(\n          \"Selected resource is not a valid folder. Please select a folder.\"\n        );\n        return;\n      }\n\n      // Ask the user to select a mode\n      const selectMode = await vscode.window.showQuickPick([\"Cubit\", \"Bloc\"], {\n        placeHolder: \"Select Mode\",\n      });\n\n      if (!selectMode) {\n        return;\n      }\n\n      // Prompt the user to input a class name\n      const className = await vscode.window.showInputBox({\n        placeHolder: \"Enter the class name\", // Placeholder text\n        prompt: \"This will create a new Dart class file\", // Prompt message\n        validateInput: (value) =>\n          value ? undefined : \"Class name cannot be empty\", // Validate that input is not empty\n      });\n\n      if (!className) {\n        return; // Cancel the operation if no class name is entered\n      }\n\n      // Ask the user if a new folder is needed for the files\n      const createNewFolder = await vscode.window.showQuickPick([\"Yes\", \"No\"], {\n        placeHolder: \"Do you want to create a new folder for the files?\", // Prompt message\n      });\n\n      if (!createNewFolder) {\n        return; // Cancel the operation if no choice is made\n      }\n\n      // Determine the target folder path\n      const targetFolderPath =\n        createNewFolder === \"Yes\"\n          ? path.join(uri.fsPath, formatClassName(className)) // Create a new folder if \"Yes\" is selected\n          : uri.fsPath; // Use the current folder if \"No\" is selected\n\n      // Create the Dart class files\n      if(selectMode === \"Bloc\"){\n        createBlocClassFile(\n          className,\n          targetFolderPath,\n          createNewFolder === \"Yes\" // Pass a flag indicating whether to create a new folder\n        );\n      }else{\n        createCubitClassFile(\n          className,\n          targetFolderPath,\n          createNewFolder === \"Yes\" // Pass a flag indicating whether to create a new folder\n        );\n      }\n    }\n  );\n\n  // Add the command to the extension's subscription list\n  context.subscriptions.push(disposable);\n}\n\n// This method is called when your extension is deactivated\nexport function deactivate() {}\n\n/**\n * Creates a new Bloc implementation with associated event and state files.\n * This function generates three files:\n * 1. bloc file - Contains the main Bloc class implementation\n * 2. event file - Defines the events that the Bloc can handle\n * 3. state file - Defines the state structure for the Bloc\n */\nfunction createBlocClassFile(\n  className: string,\n  folderPath: string,\n  createFolder: boolean\n) {\n  // Format the class name to snake_case\n  const formattedClassName = formatClassName(className);\n\n  // Convert the class name to PascalCase\n  const upperClassName = className.replace(/(?:^|\\_)([a-z])/g, (match) =>\n    match.toUpperCase()\n  );\n\n  // Check if folderPath already contains formattedClassName to avoid duplicate concatenation\n  const classFolderPath = createFolder\n    ? folderPath.endsWith(formattedClassName)\n      ? folderPath // If the path already contains the class name, use it directly\n      : path.join(folderPath, formattedClassName) // Otherwise, append the new path\n    : folderPath;\n\n  // Check if the target folder already exists to avoid duplicate creation\n  if (!fs.existsSync(classFolderPath)) {\n    fs.mkdirSync(classFolderPath, { recursive: true });\n  }\n\n  // Define file paths\n  const classFilePathBloc = path.join(\n    classFolderPath,\n    `${formattedClassName}_bloc.dart`\n  );\n  const classFilePathEvent = path.join(\n    classFolderPath,\n    `${formattedClassName}_event.dart`\n  );\n  const classFilePathState = path.join(\n    classFolderPath,\n    `${formattedClassName}_state.dart`\n  );\n\n  // Define template content\n  const blocTemplate = `import 'package:bloc/bloc.dart';\n\nimport '${formattedClassName.toLowerCase()}_event.dart';\nimport '${formattedClassName.toLowerCase()}_state.dart';\n\nclass ${upperClassName}Bloc extends Bloc<${upperClassName}Event, ${upperClassName}State> {\n  ${upperClassName}Bloc() : super(${upperClassName}State()) {\n    on<InitEvent>(_init);\n  }\n\n  void _init(InitEvent event, Emitter<${upperClassName}State> emit) async {\n    emit(state.clone());\n  }\n}`;\n\n  const eventTemplate = `abstract class ${upperClassName}Event {}\n\nclass InitEvent extends ${upperClassName}Event {}`;\n\n  const stateTemplate = `class ${upperClassName}State {\n  ${upperClassName}State clone() {\n    return ${upperClassName}State();\n  }\n}`;\n\n  // Write content to files\n  fs.writeFileSync(classFilePathBloc, blocTemplate);\n  fs.writeFileSync(classFilePathEvent, eventTemplate);\n  fs.writeFileSync(classFilePathState, stateTemplate);\n\n  vscode.window.showInformationMessage(\n    `Bloc Class ${upperClassName} created successfully in ${classFolderPath}.`\n  );\n}\n\n/**\n * Creates a new Cubit implementation with associated state file.\n * This function generates two files:\n * 1. cubit file - Contains the main Cubit class implementation\n * 2. state file - Defines the state structure for the Cubit\n */\nfunction createCubitClassFile(\n  className: string,\n  folderPath: string,\n  createFolder: boolean\n) {\n  // Format the class name to snake_case\n  const formattedClassName = formatClassName(className);\n\n  // Convert the class name to PascalCase\n  const upperClassName = className.replace(/(?:^|\\_)([a-z])/g, (match) =>\n    match.toUpperCase()\n  );\n\n  // Check if folderPath already contains formattedClassName to avoid duplicate concatenation\n  const classFolderPath = createFolder\n    ? folderPath.endsWith(formattedClassName)\n      ? folderPath // If the path already contains the class name, use it directly\n      : path.join(folderPath, formattedClassName) // Otherwise, append the new path\n    : folderPath;\n\n  // Check if the target folder already exists to avoid duplicate creation\n  if (!fs.existsSync(classFolderPath)) {\n    fs.mkdirSync(classFolderPath, { recursive: true });\n  }\n\n  // Define file paths\n  const classFilePathCubit = path.join(\n    classFolderPath,\n    `${formattedClassName}_cubit.dart`\n  );\n  const classFilePathState = path.join(\n    classFolderPath,\n    `${formattedClassName}_state.dart`\n  );\n\n  // Define template content\n  const blocTemplate = `import 'package:bloc/bloc.dart';\n\nimport '${formattedClassName.toLowerCase()}_state.dart';\n\nclass ${upperClassName}Cubit extends Cubit<${upperClassName}State> {\n  ${upperClassName}Cubit() : super(${upperClassName}State()) {\n\n  }\n}`;\n\n\n  const stateTemplate = `class ${upperClassName}State {\n  ${upperClassName}State clone() {\n    return ${upperClassName}State();\n  }\n}`;\n\n  // Write content to files\n  fs.writeFileSync(classFilePathCubit, blocTemplate);\n  fs.writeFileSync(classFilePathState, stateTemplate);\n\n  vscode.window.showInformationMessage(\n    `Cubit Class ${upperClassName} created successfully in ${classFolderPath}.`\n  );\n}\n\n/**\n * Utility function to convert a class name from PascalCase/camelCase to snake_case.\n * Example: \"UserProfile\" becomes \"user_profile\"\n * @param className - The original class name in PascalCase or camelCase\n * @returns The formatted class name in snake_case\n */\nfunction formatClassName(className: string): string {\n  // Use a regular expression to convert camelCase or PascalCase to snake_case\n  return className.replace(/([a-z])([A-Z])/g, \"$1_$2\").toLowerCase();\n}\n","module.exports = require(\"vscode\");","module.exports = require(\"fs\");","module.exports = require(\"path\");","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(265);\n"],"names":["context","disposable","vscode","commands","registerCommand","async","uri","fsPath","folderUri","window","showOpenDialog","canSelectFolders","canSelectFiles","openLabel","length","showErrorMessage","workspaceFolders","workspace","scheme","console","error","selectedPath","fs","existsSync","lstatSync","isDirectory","selectMode","showQuickPick","placeHolder","className","showInputBox","prompt","validateInput","value","undefined","createNewFolder","targetFolderPath","path","join","formatClassName","folderPath","createFolder","formattedClassName","upperClassName","replace","match","toUpperCase","classFolderPath","endsWith","mkdirSync","recursive","classFilePathBloc","classFilePathEvent","classFilePathState","blocTemplate","toLowerCase","eventTemplate","stateTemplate","writeFileSync","showInformationMessage","createBlocClassFile","classFilePathCubit","createCubitClassFile","subscriptions","push","module","exports","require","__webpack_module_cache__","__webpack_exports__","__webpack_require__","moduleId","cachedModule","__webpack_modules__","call"],"sourceRoot":""}